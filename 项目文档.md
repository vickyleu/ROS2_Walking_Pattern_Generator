# ROS2 人形机器人步行模式生成器 - 项目文档

## 目录
1. [项目概述](#项目概述)
2. [软件架构](#软件架构)
3. [实现路径](#实现路径)
4. [步态生成原理](#步态生成原理)
5. [核心模块说明](#核心模块说明)
6. [技术细节](#技术细节)

---

## 项目概述

### 项目简介
ROS2_Walking_Pattern_Generator 是一个基于 ROS 2 的人形机器人步行控制系统。该项目专注于开发一个可扩展、通用且简单易用的步行控制软件，旨在使人形机器人能够无需复杂配置即可实现稳定步行。

### 主要特性
- **插件化架构**：采用 ROS 2 插件系统，便于扩展和替换各个功能模块
- **模块化设计**：将步行控制分解为多个独立的功能模块
- **理论基础**：基于线性倒立摆模型（LIPM）进行步态规划
- **实时控制**：支持在线和离线两种模式生成步行模式

### 技术栈
- **操作系统**：Ubuntu 24.04（推荐）
- **ROS 版本**：ROS 2 Jazzy
- **数学库**：Eigen3
- **仿真环境**：Webots R2025a（可选）
- **编程语言**：C++17

---

## 软件架构

### 整体架构图
```
┌─────────────────────────────────────────────────────────┐
│                    Robot Manager                        │
│              (系统协调与调度中心)                        │
└─────────────────────────────────────────────────────────┘
         │              │              │              │
         ▼              ▼              ▼              ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│ Foot Step   │ │  Walking   │ │  Walking    │ │  Convert    │
│  Planner    │ │  Pattern    │ │Stabilization│ │   To Joint  │
│             │ │ Generator   │ │ Controller  │ │   States    │
└─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘
     │                │                │                │
     ▼                ▼                ▼                ▼
┌─────────────────────────────────────────────────────────┐
│              Parameter Server (参数服务器)               │
└─────────────────────────────────────────────────────────┘
     │                │                │                │
     ▼                ▼                ▼                ▼
┌─────────────────────────────────────────────────────────┐
│         Kinematics (运动学模块: FK, IK, Jacobian)        │
└─────────────────────────────────────────────────────────┘
```

### 模块说明

#### 1. Robot Manager（机器人管理器）
- **职责**：系统的核心协调器，负责加载和管理各个插件模块
- **功能**：
  - 插件加载与生命周期管理
  - 控制循环调度（10ms 周期）
  - 数据流协调
  - 调试模式支持

#### 2. Foot Step Planner（足部步态规划器）
- **职责**：规划机器人足部的着地位置序列
- **输入**：步行参数（步长、步宽、步行周期等）
- **输出**：足部着地位置序列（FootStep）

#### 3. Walking Pattern Generator（步行模式生成器）
- **职责**：基于足部规划生成重心轨迹和 ZMP 轨迹
- **核心算法**：线性倒立摆模型（LIPM）
- **输出**：重心位置、重心速度、ZMP 位置参考轨迹

#### 4. Walking Stabilization Controller（步行稳定控制器）
- **职责**：对生成的步行模式进行稳定化处理
- **功能**：目前为默认实现（直接传递），可扩展为基于反馈的稳定控制

#### 5. Convert To Joint States（关节状态转换器）
- **职责**：将足部轨迹转换为关节角度和角速度
- **功能**：
  - 足部轨迹计算（支持脚/游脚）
  - 逆运动学求解（IK）
  - 雅可比矩阵计算
  - 关节速度计算

#### 6. Kinematics（运动学模块）
- **Forward Kinematics（正运动学）**：根据关节角度计算末端执行器位置
- **Inverse Kinematics（逆运动学）**：根据末端执行器位置计算关节角度
- **Jacobian（雅可比矩阵）**：计算关节速度与末端速度的映射关系

---

## 实现路径

### 数据流路径

```
用户输入/参数配置
    │
    ▼
Foot Step Planner
    │ (FootStep: 足部着地位置序列)
    ▼
Walking Pattern Generator (LIPM)
    │ (WalkingPattern: 重心轨迹 + ZMP轨迹)
    ▼
Walking Stabilization Controller
    │ (WalkingStabilization: 稳定化后的轨迹)
    ▼
Convert To Joint States
    │ (LegJointStatesPattern: 关节角度 + 关节速度)
    ▼
Robot Manager (发布到 /joint_states)
    │
    ▼
机器人执行 / Webots 仿真
```

### 控制循环流程

#### 离线模式（Offline Mode）
1. **初始化阶段**：
   - 加载所有插件
   - 从参数服务器读取配置
   - 初始化运动学模块

2. **规划阶段**（一次性生成）：
   ```
   FootStepPlanner::foot_step_planner()
       → 生成完整的足部着地序列
   
   WalkingPatternGenerator::walking_pattern_generator(foot_step_ptr)
       → 基于 LIPM 生成完整的重心和 ZMP 轨迹
   ```

3. **执行阶段**（循环执行，10ms 周期）：
   ```
   while (control_step < walking_pattern.size()) {
       WalkingStabilizationController::walking_stabilization_controller()
           → 获取当前步的稳定化轨迹
       
       ConvertToJointStates::convert_to_joint_states()
           → 计算当前时刻的关节角度和速度
       
       RobotManager::publish_joint_states()
           → 发布关节状态到 /joint_states
       
       control_step++
   }
   ```

#### 在线模式（Online Mode）
- 支持实时重新规划（当前版本主要支持离线模式）

---

## 步态生成原理

### 线性倒立摆模型（Linear Inverted Pendulum Model, LIPM）

#### 1. 模型假设
线性倒立摆模型是对人形机器人步行的简化建模，主要假设包括：

- **质量集中**：机器人质量集中在重心（CoG）点
- **恒定高度**：重心在步行过程中保持恒定高度（z = const）
- **点接触**：足部与地面为点接触
- **无摩擦**：忽略足部与地面的摩擦

#### 2. 数学模型

##### 2.1 动力学方程
在 X-Y 平面内，线性倒立摆的动力学方程为：

```
ẍ = (g/z) * (x - x_zmp)
ÿ = (g/z) * (y - y_zmp)
```

其中：
- `(x, y)`：重心在水平面的位置
- `(x_zmp, y_zmp)`：零力矩点（ZMP）位置
- `g`：重力加速度（9.81 m/s²）
- `z`：重心高度（恒定）

##### 2.2 时常数
定义时常数 `T_c`：

```
T_c = √(z/g)
```

时常数反映了系统的动态特性，决定了重心运动的快慢。

##### 2.3 解析解
对于给定的初始条件 `(x₀, ẋ₀)` 和 ZMP 位置 `x_zmp`，系统在时间 `t` 的解为：

```
x(t) = (x₀ - x_zmp) * cosh(t/T_c) + T_c * ẋ₀ * sinh(t/T_c) + x_zmp
ẋ(t) = ((x₀ - x_zmp)/T_c) * sinh(t/T_c) + ẋ₀ * cosh(t/T_c)
```

其中 `sinh` 和 `cosh` 为双曲正弦和双曲余弦函数。

#### 3. 步态生成算法

##### 3.1 步行素片（Walking Segment）
一个步行周期被分解为多个"步行素片"，每个素片对应一次单脚支撑期。

##### 3.2 着地位置优化
对于每个步行素片，系统需要确定最优的 ZMP 位置（即着地位置），使得：
- 重心位置平滑过渡
- 重心速度连续
- 满足步行目标（步长、步宽等）

优化目标函数：

```
J = w_pos * (x_d - x(T))² + w_vel * (ẋ_d - ẋ(T))²
```

其中：
- `(x_d, ẋ_d)`：目标最终状态
- `(x(T), ẋ(T))`：实际最终状态
- `w_pos, w_vel`：位置和速度的权重

通过最小化该目标函数，可以得到最优的 ZMP 位置。

##### 3.3 算法流程

```cpp
// 伪代码示例
for each walking_segment:
    // 1. 计算步行素片参数
    x_bar = (foot_pos[next] - foot_pos[current]) / 2
    y_bar = (foot_pos[next] - foot_pos[current]) / 2
    
    // 2. 计算目标最终状态
    x_d = foot_pos[current] + x_bar
    ẋ_d = ((cosh(T/T_c) + 1) / (T_c * sinh(T/T_c))) * x_bar
    
    // 3. 优化计算最优 ZMP 位置
    x_zmp = optimize_zmp(x_0, ẋ_0, x_d, ẋ_d, T)
    
    // 4. 生成重心轨迹
    for t in [0, T]:
        x(t) = (x_0 - x_zmp) * cosh(t/T_c) + T_c * ẋ_0 * sinh(t/T_c) + x_zmp
        ẋ(t) = ((x_0 - x_zmp)/T_c) * sinh(t/T_c) + ẋ_0 * cosh(t/T_c)
        
    // 5. 更新初始状态
    x_0 = x(T)
    ẋ_0 = ẋ(T)
```

#### 4. 足部轨迹生成

##### 4.1 支持脚（Supporting Leg）
- 支持脚保持与地面接触
- 位置固定在当前 ZMP 位置
- 高度保持为 `-waist_height`

##### 4.2 游脚（Swing Leg）
游脚轨迹分为三个阶段：

1. **双足支撑期（前半）**：游脚准备抬起
2. **单足支撑期**：游脚抬起并向前摆动
   - X-Y 方向：线性插值从上一个着地位置到下一个着地位置
   - Z 方向：正弦波轨迹实现抬脚动作
     ```
     z_swing(t) = height_lift * sin(π * (t - T_dsup/2) / (T - T_dsup))
     ```
3. **双足支撑期（后半）**：游脚下落准备着地

##### 4.3 关节角度计算
通过逆运动学（IK）将足部位置转换为关节角度：

```
Foot Position (x, y, z) + Foot Orientation (R)
    ↓ Inverse Kinematics
Joint Angles (θ₁, θ₂, ..., θ₆)
```

##### 4.4 关节速度计算
通过雅可比矩阵计算关节速度：

```
ẋ_foot = J(θ) * θ̇
    ↓
θ̇ = J⁻¹(θ) * ẋ_foot
```

其中 `ẋ_foot` 由重心速度和游脚速度确定。

---

## 核心模块说明

### 1. Foot Step Planner（足部步态规划器）

**文件位置**：
- `foot_step_planner/include/foot_step_planner/FootStepPlanner.hpp`
- `foot_step_planner/src/FootStepPlanner.cpp`

**主要功能**：
- 根据步行参数生成足部着地位置序列
- 支持本地坐标系和世界坐标系

**关键参数**：
- `walking_cycle`：步行周期（秒）
- `waist_height`：腰部高度（米）
- `foot_pos`：足部着地位置序列 `{{x₁, y₁}, {x₂, y₂}, ...}`

**输出数据结构**：
```cpp
struct FootStep {
    std::vector<std::array<double, 2>> foot_pos;  // 着地位置序列
    double walking_step_time;                      // 步行周期
    double waist_height;                            // 腰部高度
};
```

### 2. Walking Pattern Generator（步行模式生成器）

**文件位置**：
- `walking_pattern_generator/include/walking_pattern_generator/LinearInvertedPendulumModel.hpp`
- `walking_pattern_generator/src/LinearInvertedPendulumModel.cpp`

**核心类**：`WPG_LinearInvertedPendulumModel`

**主要功能**：
- 实现线性倒立摆模型算法
- 生成重心轨迹和 ZMP 轨迹
- 优化着地位置

**关键参数**：
- `CONTROL_CYCLE_`：控制周期（默认 0.01 秒）
- `WALKING_CYCLE_`：步行周期（默认 0.8 秒）
- `WAIST_POS_Z_`：腰部高度（米）

**输出数据结构**：
```cpp
struct WalkingPattern {
    std::vector<std::array<double, 3>> cc_cog_pos_ref;      // 重心位置参考（相对坐标系）
    std::vector<std::array<double, 3>> cc_cog_vel_ref;      // 重心速度参考
    std::vector<std::array<double, 2>> wc_foot_land_pos_ref; // ZMP/着地位置参考（世界坐标系）
};
```

**核心算法实现**：
```cpp
// 时常数计算
T_c = sqrt(WAIST_POS_Z_ / 9.81);

// 重心位置计算
x(t) = (x_0 - x_zmp) * cosh(t/T_c) + T_c * dx_0 * sinh(t/T_c) + x_zmp;

// 重心速度计算
dx(t) = ((x_0 - x_zmp)/T_c) * sinh(t/T_c) + dx_0 * cosh(t/T_c);
```

### 3. Walking Stabilization Controller（步行稳定控制器）

**文件位置**：
- `walking_stabilization_controller/include/walking_stabilization_controller/WalkingStabilizationController.hpp`
- `walking_stabilization_controller/src/WalkingStabilizationController.cpp`

**当前实现**：
- 默认实现：直接传递步行模式数据
- 可扩展：可添加基于传感器反馈的稳定控制算法

**输出数据结构**：
```cpp
struct WalkingStabilization {
    std::vector<std::array<double, 3>> cog_pos_fix;      // 稳定化后的重心位置
    std::vector<std::array<double, 3>> cog_vel_fix;       // 稳定化后的重心速度
    std::vector<std::array<double, 2>> zmp_pos_fix;      // 稳定化后的 ZMP 位置
};
```

### 4. Convert To Joint States（关节状态转换器）

**文件位置**：
- `convert_to_joint_states/include/convert_to_joint_states/ConvertToJointStates.hpp`
- `convert_to_joint_states/src/ConvertToJointStates.cpp`

**主要功能**：
1. **足部轨迹计算**：
   - 支持脚位置：固定在 ZMP 位置
   - 游脚轨迹：X-Y 线性插值 + Z 正弦波抬脚

2. **逆运动学求解**：
   - 调用 `kinematics::InverseKinematics` 插件
   - 输入：足部位置和姿态
   - 输出：6 个关节角度

3. **雅可比矩阵计算**：
   - 调用 `kinematics::Jacobian` 插件
   - 计算关节速度

**输出数据结构**：
```cpp
struct LegJointStatesPattern {
    std::array<double, 6> joint_ang_pat_legR;   // 右腿关节角度
    std::array<double, 6> joint_vel_pat_legR;   // 右腿关节速度
    std::array<double, 6> joint_ang_pat_legL;   // 左腿关节角度
    std::array<double, 6> joint_vel_pat_legL;   // 左腿关节速度
};
```

### 5. Robot Manager（机器人管理器）

**文件位置**：
- `robot_manager/include/robot_manager/robot_manager.hpp`
- `robot_manager/src/robot_manager.cpp`

**主要功能**：
- 插件加载与管理
- 控制循环调度（10ms 定时器）
- 数据发布（`/joint_states`）
- 调试模式支持（记录数据）

**关键流程**：
```cpp
// 1. 加载插件
fsp_ = fsp_loader_.createSharedInstance("foot_step_planner::Default_FootStepPlanner");
wpg_ = wpg_loader_.createSharedInstance("walking_pattern_generator::WPG_LinearInvertedPendulumModel");
wsc_ = wsc_loader_.createSharedInstance("walking_stabilization_controller::Default_WalkingStabilizationController");
ctjs_ = ctjs_loader_.createSharedInstance("convert_to_joint_states::Default_ConvertToJointStates");

// 2. 离线生成（一次性）
foot_step_ptr_ = fsp_->foot_step_planner();
walking_pattern_ptr_ = wpg_->walking_pattern_generator(foot_step_ptr_);

// 3. 控制循环（10ms）
wall_timer_ = create_wall_timer(10ms, Step_Offline);
```

---

## 技术细节

### 1. 插件系统

项目采用 ROS 2 的 `pluginlib` 实现插件化架构：

**插件基类定义**：
- `control_plugin_base::FootStepPlanner`
- `control_plugin_base::WalkingPatternGenerator`
- `control_plugin_base::WalkingStabilizationController`
- `control_plugin_base::ConvertToJointStates`

**插件注册**：
```cpp
PLUGINLIB_EXPORT_CLASS(
    walking_pattern_generator::WPG_LinearInvertedPendulumModel,
    control_plugin_base::WalkingPatternGenerator
);
```

**插件加载**：
```cpp
pluginlib::ClassLoader<control_plugin_base::WalkingPatternGenerator> wpg_loader_(
    "robot_manager", "control_plugin_base::WalkingPatternGenerator"
);
```

### 2. 参数管理

所有参数通过 ROS 2 参数服务器统一管理：

**参数服务器节点**：`RobotParameterServer`

**参数分类**：
- `control_times`：控制时间参数
  - `control_cycle`：控制周期（0.01 秒）
  - `walking_cycle`：步行周期（0.8 秒）
  - `both_leg_support_period`：双足支撑期（0.5 秒）
- `control_constant`：控制常数
  - `waist_pos_z`：腰部高度（米）
  - `height_leg_lift`：抬脚高度（0.025 米）
- `robot_description`：机器人描述
  - `robot_name`：机器人名称
  - 关节名称、单位向量、连杆长度等

### 3. 坐标系定义

**世界坐标系（World Coordinate, WC）**：
- 原点：初始着地位置
- X 轴：前进方向
- Y 轴：左右方向（左正）
- Z 轴：垂直向上

**机器人坐标系（Robot Coordinate, RC）**：
- 原点：机器人重心（腰部）
- 方向：与世界坐标系一致

**足部坐标系**：
- 支持脚：固定在 ZMP 位置
- 游脚：相对于重心的位置

### 4. 时间管理

**关键时间参数**：
- `control_cycle`：控制周期（10ms）
- `walking_cycle`：步行周期（800ms）
- `both_leg_support_period`：双足支撑期（500ms）
- `single_leg_support_period`：单足支撑期（300ms）

**时间变量**：
- `t`：当前步行素片内的时间（0 ~ walking_cycle）
- `walking_time`：总步行时间
- `walking_step`：当前步行步数
- `control_step`：当前控制步数

### 5. 数值计算

**双曲函数计算**：
```cpp
S = sinh(t / T_c);
C = cosh(t / T_c);
```

**优化计算**：
```cpp
// 优化权重
opt_weight_pos = 10;
opt_weight_vel = 1;

// 优化矩阵
D = opt_weight_pos * pow((cosh(T/T_c) - 1), 2) 
  + opt_weight_vel * pow((sinh(T/T_c) / T_c), 2);

// 最优 ZMP 位置
x_zmp = -((opt_weight_pos * (C - 1)) / D) * (x_d - C*x_0 - T_c*S*dx_0)
      - ((opt_weight_vel * S) / (T_c * D)) * (dx_d - (S/T_c)*x_0 - C*dx_0);
```

### 6. 运动学计算

**逆运动学（IK）**：
- 输入：末端执行器位置 `(x, y, z)` 和姿态矩阵 `R`
- 输出：6 个关节角度 `(θ₁, θ₂, ..., θ₆)`
- 方法：解析法或数值迭代法

**雅可比矩阵**：
- 定义：`J(θ) = ∂f(θ)/∂θ`，其中 `f(θ)` 为正运动学函数
- 用途：计算关节速度 `θ̇ = J⁻¹(θ) * ẋ`

---

## 总结

本项目实现了一个完整的人形机器人步行控制系统，核心特点包括：

1. **模块化设计**：通过插件系统实现高度可扩展的架构
2. **理论基础扎实**：基于线性倒立摆模型的步态生成算法
3. **工程实现完善**：从规划到执行的完整数据流
4. **易于扩展**：各模块可独立替换和优化

### 未来改进方向

1. **在线重规划**：支持实时根据传感器反馈调整步态
2. **稳定控制增强**：添加基于 ZMP 反馈的稳定控制算法
3. **多步态支持**：支持跑步、上下楼梯等复杂步态
4. **参数自适应**：根据机器人状态自动调整控制参数

---

## 参考文献

1. Kajita, S., et al. "Biped walking pattern generation by using preview control of zero-moment point." *IEEE International Conference on Robotics and Automation*, 2003.
2. 梶田秀司. 『ヒューマノイドロボット（改訂２版）』. オーム社, 2016.
3. ROS 2 Documentation: https://docs.ros.org/en/jazzy/

---

**文档版本**：1.0  
**最后更新**：2024年  
**维护者**：项目开发团队

